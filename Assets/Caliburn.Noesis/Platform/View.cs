namespace Caliburn.Noesis
{
    using System;
    using System.Linq;
    using Extensions;
    using JetBrains.Annotations;
    using Microsoft.Extensions.Logging;
    using LogLevel = Microsoft.Extensions.Logging.LogLevel;
#if UNITY_5_5_OR_NEWER
    using global::Noesis;

#else
    using System.Windows;
    using System.Windows.Controls;
    using System.Windows.Markup;
    using System.Windows.Media;
#endif

    /// <summary>Hosts attached properties related to view-models.</summary>
    [PublicAPI]
    public static class View
    {
        #region Constants and Fields

        /// <summary>A dependency property for marking an element as framework generated.</summary>
        public static readonly DependencyProperty IsGeneratedProperty = DependencyProperty.RegisterAttached(
            PropertyNameHelper.GetName(nameof(IsGeneratedProperty)),
            typeof(bool),
            typeof(View),
            new PropertyMetadata(default(bool)));

        private static readonly DependencyProperty ContextProperty = DependencyProperty.RegisterAttached(
            PropertyNameHelper.GetName(nameof(ContextProperty)),
            typeof(Guid),
            typeof(View),
            new PropertyMetadata(default(Guid)));

        private static readonly ContentPropertyAttribute DefaultContentProperty =
            new ContentPropertyAttribute(nameof(ContentControl.Content));

        /// <summary>A dependency property for attaching a model to the UI.</summary>
        public static DependencyProperty ModelProperty = DependencyProperty.RegisterAttached(
            PropertyNameHelper.GetName(nameof(ModelProperty)),
            typeof(object),
            typeof(View),
            new PropertyMetadata(default, OnModelChanged));

        #endregion

        #region Private Properties

        private static ILogger Logger => LogManager.FrameworkLogger;

        #endregion

        #region Public Methods

        /// <summary>Gets a value indicating whether the element was generated by the framework.</summary>
        /// <param name="element">The element to check.</param>
        /// <returns><c>true</c> if the element was generated by the framework; otherwise, <c>false</c>.</returns>
        public static bool GetIsGenerated(DependencyObject element)
        {
            return (bool)element.GetValue(IsGeneratedProperty);
        }

        /// <summary>Gets the model.</summary>
        /// <param name="d">The element the model is attached to.</param>
        /// <returns>The model.</returns>
        public static object GetModel(DependencyObject d)
        {
            return d.GetValue(ModelProperty);
        }

        /// <summary>Sets a value indicating whether the element was generated by the framework.</summary>
        /// <param name="element">The element to mark as generated.</param>
        /// <param name="value">If set to <c>true</c> the element is marked as generated by the framework.</param>
        public static void SetIsGenerated(DependencyObject element, bool value)
        {
            element.SetValue(IsGeneratedProperty, value);
        }

        /// <summary>Sets the model.</summary>
        /// <param name="d">The element to attach the model to.</param>
        /// <param name="value">The model.</param>
        public static void SetModel(DependencyObject d, object value)
        {
            d.SetValue(ModelProperty, value);
        }

        #endregion

        #region Private Methods

        private static UIElement GetCachedViewFor(object viewModel, DependencyObject contextLocation)
        {
            var context = GetContext(contextLocation);

            if (!(viewModel is IViewAware viewAware) || (context == Guid.Empty))
            {
                return null;
            }

            return viewAware.GetView(context);
        }

        private static Guid GetContext(DependencyObject element)
        {
            return (Guid)element.GetValue(ContextProperty);
        }

        private static void OnModelChanged(DependencyObject targetLocation, DependencyPropertyChangedEventArgs args)
        {
            using var _ = Logger.GetMethodTracer(targetLocation, args);

            if (args.OldValue == args.NewValue)
            {
                return;
            }

            var viewModel = args.NewValue;

            if (viewModel is null)
            {
                SetContentProperty(targetLocation, null);

                return;
            }

            var contextLocation = targetLocation.FindFirstNonGeneratedAncestor();

            var context = GetContext(contextLocation);

            if (GetCachedViewFor(viewModel, contextLocation) is { } cachedView)
            {
                if (Logger.IsEnabled(LogLevel.Debug))
                {
                    // Only do this if the log level is active because FindAncestorDeclaredInUserControl()
                    // should not be called unnecessarily.
                    Logger.LogDebug(
                        "Using cached view for {ViewModel} at location {@LocationInView} with context ID {ContextID}",
                        viewModel,
                        contextLocation.FindAncestorDeclaredInUserControl(),
                        context);
                }

                SetContentProperty(targetLocation, cachedView);

                return;
            }

            var foundServices = TryGetServices(
                targetLocation,
                out var serviceProvider,
                out var assemblySource,
                out var viewLocator);

            if (foundServices)
            {
                var view = viewLocator.LocateForModel(viewModel, serviceProvider, assemblySource);

                if (viewModel is IViewAware viewAware &&
                    !ReferenceEquals(GetCachedViewFor(viewModel, contextLocation), view))
                {
                    if (context == Guid.Empty)
                    {
                        context = Guid.NewGuid();
                    }

                    if (Logger.IsEnabled(LogLevel.Debug))
                    {
                        // Only do this if the log level is active because GetAncestorDeclaredInUserControl()
                        // should not be called unnecessarily.
                        Logger.LogDebug(
                            "Attaching {@View} to {ViewModel} at location {@LocationInView} with context ID {ContextID}",
                            view,
                            viewAware,
                            contextLocation.FindAncestorDeclaredInUserControl(),
                            context);
                    }

                    SetContext(contextLocation, context);

                    viewAware.AttachView(view, context);
                }

                if (!SetContentProperty(targetLocation, view))
                {
                    Logger.LogWarning(
                        "{SetContentProperty}() failed for {ViewLocator}.{LocateForModel}(), falling back to {LocateForModelType}()",
                        nameof(SetContentProperty),
                        nameof(ViewLocator),
                        nameof(ViewLocator.LocateForModel),
                        nameof(ViewLocator.LocateForModelType));

                    view = viewLocator.LocateForModelType(viewModel.GetType(), serviceProvider, assemblySource);

                    SetContentProperty(targetLocation, view);
                }
            }
            else
            {
                SetContentProperty(targetLocation, null);
            }
        }

        private static bool SetContentProperty(object targetLocation, object view)
        {
            if (view is FrameworkElement { Parent: { } } frameworkElement)
            {
                SetContentPropertyCore(frameworkElement.Parent, null);
            }

            return SetContentPropertyCore(targetLocation, view);
        }

        private static bool SetContentPropertyCore(object targetLocation, object view)
        {
            try
            {
                var type = targetLocation.GetType();
                var contentProperty =
                    type.GetCustomAttributes(typeof(ContentPropertyAttribute), true)
                        .OfType<ContentPropertyAttribute>()
                        .FirstOrDefault() ??
                    DefaultContentProperty;

                var propertyInfo = type.GetProperty(contentProperty?.Name ?? DefaultContentProperty.Name);

                if (propertyInfo == null)
                {
                    return false;
                }

                propertyInfo.SetValue(targetLocation, view, null);

                return true;
            }
            catch (Exception)
            {
                return false;
            }
        }

        private static void SetContext(DependencyObject element, Guid context)
        {
            element.SetValue(ContextProperty, context);
        }

        private static bool TryGetServices(DependencyObject dependencyObject,
                                           out IServiceProvider serviceProvider,
                                           out AssemblySource assemblySource,
                                           out ViewLocator viewLocator)
        {
            using var _ = Logger.GetMethodTracer(dependencyObject, null, null, null);

            var frameworkElement = dependencyObject.FindVisualAncestor<FrameworkElement>();
            serviceProvider = frameworkElement?.TryFindResource(nameof(IServiceProvider)) as IServiceProvider;
            assemblySource = frameworkElement?.TryFindResource(nameof(AssemblySource)) as AssemblySource;
            viewLocator = frameworkElement?.TryFindResource(nameof(ViewLocator)) as ViewLocator;

            return (serviceProvider != null) && (assemblySource != null) && (viewLocator != null);
        }

        #endregion
    }
}