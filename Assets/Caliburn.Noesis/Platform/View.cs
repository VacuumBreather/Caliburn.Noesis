namespace Caliburn.Noesis
{
    using System;
    using System.Linq;
    using Extensions;
    using JetBrains.Annotations;
    using Microsoft.Extensions.Logging;
#if UNITY_5_5_OR_NEWER
    using global::Noesis;

#else
    using System.Windows;
    using System.Windows.Controls;
    using System.Windows.Markup;
    using System.Windows.Media;
#endif

    /// <summary>Hosts attached properties related to view-models.</summary>
    [PublicAPI]
    public static class View
    {
        #region Constants and Fields

        /// <summary>A dependency property for marking an element as framework generated.</summary>
        public static readonly DependencyProperty IsGeneratedProperty =
            DependencyProperty.RegisterAttached(
                PropertyNameHelper.GetName(nameof(IsGeneratedProperty)),
                typeof(bool),
                typeof(View),
                new PropertyMetadata(default(bool)));

        private static readonly DependencyProperty ContextProperty =
            DependencyProperty.RegisterAttached(
                PropertyNameHelper.GetName(nameof(ContextProperty)),
                typeof(Guid),
                typeof(View),
                new PropertyMetadata(default(Guid)));

        private static readonly ContentPropertyAttribute DefaultContentProperty =
            new ContentPropertyAttribute(nameof(ContentControl.Content));

        /// <summary>A dependency property for attaching a model to the UI.</summary>
        public static DependencyProperty ModelProperty = DependencyProperty.RegisterAttached(
            PropertyNameHelper.GetName(nameof(ModelProperty)),
            typeof(object),
            typeof(View),
            new PropertyMetadata(default, OnModelChanged));

        #endregion

        #region Private Properties

        private static ILogger Logger => LogManager.FrameworkLogger;

        #endregion

        #region Public Methods

        /// <summary>Gets the cached view for the specified view-model and location, if any.</summary>
        /// <param name="viewModel">A view-model.</param>
        /// <param name="targetLocation">The target location at which the view should appear.</param>
        /// <returns>The cached view or <c>null</c> if no view was cached for the specified location.</returns>
        public static UIElement GetCachedViewFor(object viewModel, DependencyObject targetLocation)
        {
            var context = GetContext(targetLocation);

            if (!(viewModel is IViewAware viewAware) || (context == Guid.Empty))
            {
                return null;
            }

            return viewAware.GetView(context);
        }

        /// <summary>Gets a value indicating whether the element was generated by the framework.</summary>
        /// <param name="element">The element to check.</param>
        /// <returns><c>true</c> if the element was generated by the framework; otherwise, <c>false</c>.</returns>
        public static bool GetIsGenerated(DependencyObject element)
        {
            return (bool)element.GetValue(IsGeneratedProperty);
        }

        /// <summary>Gets the model.</summary>
        /// <param name="d">The element the model is attached to.</param>
        /// <returns>The model.</returns>
        public static object GetModel(DependencyObject d)
        {
            return d.GetValue(ModelProperty);
        }

        /// <summary>Sets a value indicating whether the element was generated by the framework.</summary>
        /// <param name="element">The element to mark as generated.</param>
        /// <param name="value">If set to <c>true</c> the element is marked as generated by the framework.</param>
        public static void SetIsGenerated(DependencyObject element, bool value)
        {
            element.SetValue(IsGeneratedProperty, value);
        }

        /// <summary>Sets the model.</summary>
        /// <param name="d">The element to attach the model to.</param>
        /// <param name="value">The model.</param>
        public static void SetModel(DependencyObject d, object value)
        {
            d.SetValue(ModelProperty, value);
        }

        #endregion

        #region Private Methods

        private static bool CanCreateView(object viewModel,
                                          DependencyObject targetLocation,
                                          out IServiceProvider serviceProvider,
                                          out AssemblySource assemblySource,
                                          out ViewLocator viewLocator)
        {
            using var _ = Logger.GetMethodTracer(
                viewModel,
                targetLocation,
                null,
                null,
                null);

            var frameworkElement = targetLocation.FindVisualAncestor<FrameworkElement>();
            serviceProvider =
                frameworkElement?.TryFindResource(nameof(IServiceProvider)) as IServiceProvider;
            assemblySource =
                frameworkElement?.TryFindResource(nameof(AssemblySource)) as AssemblySource;
            viewLocator = frameworkElement?.TryFindResource(nameof(ViewLocator)) as ViewLocator;

            return (viewModel != null) &&
                   (serviceProvider != null) &&
                   (assemblySource != null) &&
                   (viewLocator != null);
        }

        private static Guid GetContext(DependencyObject element)
        {
            var nonGeneratedElement = GetFirstNonGeneratedAncestor(element);

            return (Guid)(nonGeneratedElement?.GetValue(ContextProperty) ?? Guid.Empty);
        }

        private static DependencyObject GetFirstNonGeneratedAncestor(DependencyObject view)
        {
            var current = view;

            while ((current != null) && GetIsGenerated(current))
            {
                current = VisualTreeHelper.GetParent(current);
            }

            return current;
        }

        private static void OnModelChanged(DependencyObject targetLocation,
                                           DependencyPropertyChangedEventArgs args)
        {
            using var _ = Logger.GetMethodTracer(targetLocation, args);

            if (args.OldValue == args.NewValue)
            {
                return;
            }

            var viewModel = args.NewValue;

            if (viewModel is null)
            {
                SetContentProperty(targetLocation, null);

                return;
            }

            var context = GetContext(targetLocation);

            if (GetCachedViewFor(viewModel, targetLocation) is { } cachedView)
            {
                Logger.LogDebug(
                    "Using cached view for {ViewModel} at location {LocationID}",
                    viewModel,
                    context);

                SetContentProperty(targetLocation, cachedView);

                return;
            }

            if (CanCreateView(
                viewModel,
                targetLocation,
                out var serviceProvider,
                out var assemblySource,
                out var viewLocator))
            {
                var view = viewLocator.LocateForModel(viewModel, serviceProvider, assemblySource);

                if (viewModel is IViewAware viewAware &&
                    !ReferenceEquals(GetCachedViewFor(viewModel, targetLocation), view))
                {
                    if (context == Guid.Empty)
                    {
                        context = Guid.NewGuid();
                    }

                    Logger.LogDebug(
                        "Attaching {@View} to {ViewModel} at location {LocationID}",
                        view,
                        viewAware,
                        context);

                    SetContext(targetLocation, context);

                    viewAware.AttachView(view, context);
                }

                if (!SetContentProperty(targetLocation, view))
                {
                    Logger.LogWarning(
                        "{SetContentProperty}() failed for {ViewLocator}.{LocateForModel}(), falling back to {LocateForModelType}()",
                        nameof(SetContentProperty),
                        nameof(ViewLocator),
                        nameof(ViewLocator.LocateForModel),
                        nameof(ViewLocator.LocateForModelType));

                    view = viewLocator.LocateForModelType(
                        viewModel.GetType(),
                        serviceProvider,
                        assemblySource);

                    SetContentProperty(targetLocation, view);
                }
            }
            else
            {
                SetContentProperty(targetLocation, null);
            }
        }

        private static bool SetContentProperty(object targetLocation, object view)
        {
            if (view is FrameworkElement { Parent: { } } frameworkElement)
            {
                SetContentPropertyCore(frameworkElement.Parent, null);
            }

            return SetContentPropertyCore(targetLocation, view);
        }

        private static bool SetContentPropertyCore(object targetLocation, object view)
        {
            try
            {
                var type = targetLocation.GetType();
                var contentProperty =
                    type.GetCustomAttributes(typeof(ContentPropertyAttribute), true)
                        .OfType<ContentPropertyAttribute>()
                        .FirstOrDefault() ??
                    DefaultContentProperty;

                var propertyInfo =
                    type.GetProperty(contentProperty?.Name ?? DefaultContentProperty.Name);

                if (propertyInfo == null)
                {
                    return false;
                }

                propertyInfo.SetValue(targetLocation, view, null);

                return true;
            }
            catch (Exception)
            {
                return false;
            }
        }

        private static void SetContext(DependencyObject element, Guid context)
        {
            var nonGeneratedElement = GetFirstNonGeneratedAncestor(element);

            nonGeneratedElement?.SetValue(ContextProperty, context);
        }

        #endregion
    }
}